#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

# Require the 'rubygems' library
require 'rubygems'

# Define a module with utility methods for activating Bundler
m = Module.new do
  module_function

  # Check if the script is invoked directly
  def invoked_as_script?
    File.expand_path($PROGRAM_NAME) == File.expand_path(__FILE__)
  end

  # Get the Bundler version from the 'BUNDLER_VERSION' environment variable
  def env_var_version
    ENV.fetch('BUNDLER_VERSION', nil)
  end

  # Get the Bundler version from the command-line arguments
  def cli_arg_version
    return unless invoked_as_script?

    bundler_version = extract_bundler_version_from_args(ARGV)
    return unless bundler_version && 'update'.start_with?(ARGV.first || ' ')

    bundler_version
  end

  private

  # Extract Bundler version from command-line arguments
  def extract_bundler_version_from_args(args)
    bundler_version = nil
    update_index = nil

    args.each_with_index do |arg, index|
      if bundler_version.nil? && update_index && update_index.succ == index && arg =~ Gem::Version::ANCHORED_VERSION_PATTERN
        bundler_version = arg
        break
      end

      next unless arg =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/

      bundler_version = Regexp.last_match(1)
      update_index = index
      break
    end

    bundler_version
  end

  # Get the path to the Gemfile
  def gemfile
    gemfile = ENV.fetch('BUNDLE_GEMFILE', nil)
    return gemfile if gemfile.present?

    File.expand_path('../Gemfile', __dir__)
  end

  # Get the path to the lockfile based on the Gemfile
  def lockfile
    lockfile =
      case File.basename(gemfile)
      when 'gems.rb' then gemfile.sub(/\.rb$/, '.locked')
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  # Get the Bundler version from the lockfile
  def lockfile_version
    return unless File.file?(lockfile)

    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/

    Regexp.last_match(1)
  end

  # Get the Bundler version requirement
  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
        cli_arg_version ||
        bundler_requirement_for(lockfile_version)
  end

  # Generate the Bundler version requirement based on the version
  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  # Load Bundler and activate it
  def load_bundler!
    ENV['BUNDLE_GEMFILE'] ||= gemfile

    activate_bundler
  end

  # Activate Bundler and handle any errors during activation
  def activate_bundler
    gem_error = activation_error_handling do
      gem 'bundler', bundler_requirement
    end

    return unless gem_error

    require_error = activation_error_handling do
      require 'bundler/version'
    end

    if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
      return
    end

    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  # Output a warning message indicating the Bundler activation failure and instructions for installing the required version
  warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"

  # Exit the script with a non-zero status code to indicate an error
  exit 42
end

# Define a method for handling errors during activation
def activation_error_handling
  yield
  nil
rescue StandardError, LoadError => e
  e
end

# Load Bundler if the script is invoked as a script
m.load_bundler!

# Load the 'bundle' executable if the script is invoked as a script
load Gem.bin_path('bundler', 'bundle') if m.invoked_as_script?
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

# Require the 'rubygems' library
require 'rubygems'

# Define a module with utility methods for activating Bundler
m = Module.new do
  module_function

  # Check if the script is invoked directly
  def invoked_as_script?
    File.expand_path($PROGRAM_NAME) == File.expand_path(__FILE__)
  end

  # Get the Bundler version from the 'BUNDLER_VERSION' environment variable
  def env_var_version
    ENV.fetch('BUNDLER_VERSION', nil)
  end

  # Get the Bundler version from the command-line arguments
  def cli_arg_version
    return unless invoked_as_script?

    bundler_version = extract_bundler_version_from_args(ARGV)
    return unless bundler_version && 'update'.start_with?(ARGV.first || ' ')

    bundler_version
  end

  private

  # Extract Bundler version from command-line arguments
  def extract_bundler_version_from_args(args)
    bundler_version = nil
    update_index = nil

    args.each_with_index do |arg, index|
      if bundler_version.nil? && update_index && update_index.succ == index && arg =~ Gem::Version::ANCHORED_VERSION_PATTERN
        bundler_version = arg
        break
      end

      next unless arg =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/

      bundler_version = Regexp.last_match(1)
      update_index = index
      break
    end

    bundler_version
  end

  # Get the path to the Gemfile
  def gemfile
    gemfile = ENV.fetch('BUNDLE_GEMFILE', nil)
    return gemfile if gemfile.present?

    File.expand_path('../Gemfile', __dir__)
  end

  # Get the path to the lockfile based on the Gemfile
  def lockfile
    lockfile =
      case File.basename(gemfile)
      when 'gems.rb' then gemfile.sub(/\.rb$/, '.locked')
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  # Get the Bundler version from the lockfile
  def lockfile_version
    return unless File.file?(lockfile)

    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/

    Regexp.last_match(1)
  end

  # Get the Bundler version requirement
  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
        cli_arg_version ||
        bundler_requirement_for(lockfile_version)
  end

  # Generate the Bundler version requirement based on the version
  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)

    bundler_gem_version.approximate_recommendation
  end

  # Load Bundler and activate it
  def load_bundler!
    ENV['BUNDLE_GEMFILE'] ||= gemfile

    activate_bundler
  end

  # Activate Bundler and handle any errors during activation
  def activate_bundler
    gem_error = activation_error_handling do
      gem 'bundler', bundler_requirement
    end

    return unless gem_error

    require_error = activation_error_handling do
      require 'bundler/version'
    end

    if require_error.nil? && Gem::Requirement.new(bundler_requirement).satisfied_by?(Gem::Version.new(Bundler::VERSION))
      return
    end

    warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"
    exit 42
  end

  # Output a warning message indicating the Bundler activation failure and instructions for installing the required version
  warn "Activating bundler (#{bundler_requirement}) failed:\n#{gem_error.message}\n\nTo install the version of bundler this project requires, run `gem install bundler -v '#{bundler_requirement}'`"

  # Exit the script with a non-zero status code to indicate an error
  exit 42
end

# Define a method for handling errors during activation
def activation_error_handling
  yield
  nil
rescue StandardError, LoadError => e
  e
end

# Load Bundler if the script is invoked as a script
m.load_bundler!

# Load the 'bundle' executable if the script is invoked as a script
load Gem.bin_path('bundler', 'bundle') if m.invoked_as_script?